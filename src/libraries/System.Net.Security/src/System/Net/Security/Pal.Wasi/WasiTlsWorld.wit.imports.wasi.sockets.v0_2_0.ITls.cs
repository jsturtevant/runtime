// Generated by `wit-bindgen` 0.32.0. DO NOT EDIT!
// <auto-generated />
#nullable enable

using System;
using System.Runtime.CompilerServices;
using System.Collections;
using System.Runtime.InteropServices;
using System.Text;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

namespace WasiTlsWorld.wit.imports.wasi.sockets.v0_2_0;

internal interface ITls {

    internal class ClientConnection: IDisposable {
        internal int Handle { get; set; }

        internal readonly record struct THandle(int Handle);

        internal ClientConnection(THandle handle) {
            Handle = handle.Handle;
        }

        public void Dispose() {
            Dispose(true);
        }

        [DllImport("wasi:sockets/tls@0.2.0", EntryPoint = "[resource-drop]client-connection"), WasmImportLinkage]
        private static extern void wasmImportResourceDrop(int p0);

        protected virtual void Dispose(bool disposing) {
            if (disposing && Handle != 0) {
                wasmImportResourceDrop(Handle);
                Handle = 0;
            }
        }

        internal static class ConstructorWasmInterop
        {
            [DllImport("wasi:sockets/tls@0.2.0", EntryPoint = "[constructor]client-connection"), WasmImportLinkage]
            internal static extern int wasmImportConstructor(int p0, int p1);

        }

        internal   unsafe  ClientConnection(global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IStreams.InputStream input, global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IStreams.OutputStream output)
        {
            var handle = input.Handle;
            input.Handle = 0;
            var handle0 = output.Handle;
            output.Handle = 0;
            var result =  ConstructorWasmInterop.wasmImportConstructor(handle, handle0);
            this.Handle = result;

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class ConnectWasmInterop
        {
            [DllImport("wasi:sockets/tls@0.2.0", EntryPoint = "[method]client-connection.connect"), WasmImportLinkage]
            internal static extern void wasmImportConnect(int p0, nint p1, int p2, nint p3);

        }

        internal   unsafe global::WasiTlsWorld.wit.imports.wasi.sockets.v0_2_0.ITls.ClientHandshake Connect(string serverName)
        {
            var handle = this.Handle;

            var result = serverName;
            IntPtr interopString = InteropString.FromString(result, out int lengthresult);

            var retArea = new uint[2];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                ConnectWasmInterop.wasmImportConnect(handle, interopString.ToInt32(), lengthresult, ptr);

                Result<global::WasiTlsWorld.wit.imports.wasi.sockets.v0_2_0.ITls.ClientHandshake, None> lifted;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {
                        var resource = new global::WasiTlsWorld.wit.imports.wasi.sockets.v0_2_0.ITls.ClientHandshake(new global::WasiTlsWorld.wit.imports.wasi.sockets.v0_2_0.ITls.ClientHandshake.THandle(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 4), 4))));

                        lifted = Result<global::WasiTlsWorld.wit.imports.wasi.sockets.v0_2_0.ITls.ClientHandshake, None>.ok(resource);
                        break;
                    }
                    case 1: {

                        lifted = Result<global::WasiTlsWorld.wit.imports.wasi.sockets.v0_2_0.ITls.ClientHandshake, None>.err(new global::WasiTlsWorld.None());
                        break;
                    }

                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 0), 1)[0]}");
                }
                if (lifted.IsOk) {
                    var tmp = lifted.AsOk;
                    return tmp;
                } else {
                    throw new WitException(lifted.AsErr!, 0);
                }
            }

            //TODO: free alloc handle (interopString) if exists
        }

    }

    internal class ClientHandshake: IDisposable {
        internal int Handle { get; set; }

        internal readonly record struct THandle(int Handle);

        internal ClientHandshake(THandle handle) {
            Handle = handle.Handle;
        }

        public void Dispose() {
            Dispose(true);
        }

        [DllImport("wasi:sockets/tls@0.2.0", EntryPoint = "[resource-drop]client-handshake"), WasmImportLinkage]
        private static extern void wasmImportResourceDrop(int p0);

        protected virtual void Dispose(bool disposing) {
            if (disposing && Handle != 0) {
                wasmImportResourceDrop(Handle);
                Handle = 0;
            }
        }

        internal static class FinishWasmInterop
        {
            [DllImport("wasi:sockets/tls@0.2.0", EntryPoint = "[static]client-handshake.finish"), WasmImportLinkage]
            internal static extern int wasmImportFinish(int p0);

        }

        internal  static unsafe global::WasiTlsWorld.wit.imports.wasi.sockets.v0_2_0.ITls.FutureStreams Finish(global::WasiTlsWorld.wit.imports.wasi.sockets.v0_2_0.ITls.ClientHandshake @this)
        {
            var handle = @this.Handle;
            @this.Handle = 0;
            var result =  FinishWasmInterop.wasmImportFinish(handle);
            var resource = new global::WasiTlsWorld.wit.imports.wasi.sockets.v0_2_0.ITls.FutureStreams(new global::WasiTlsWorld.wit.imports.wasi.sockets.v0_2_0.ITls.FutureStreams.THandle(result));
            return resource;

            //TODO: free alloc handle (interopString) if exists
        }

    }

    internal class FutureStreams: IDisposable {
        internal int Handle { get; set; }

        internal readonly record struct THandle(int Handle);

        internal FutureStreams(THandle handle) {
            Handle = handle.Handle;
        }

        public void Dispose() {
            Dispose(true);
        }

        [DllImport("wasi:sockets/tls@0.2.0", EntryPoint = "[resource-drop]future-streams"), WasmImportLinkage]
        private static extern void wasmImportResourceDrop(int p0);

        protected virtual void Dispose(bool disposing) {
            if (disposing && Handle != 0) {
                wasmImportResourceDrop(Handle);
                Handle = 0;
            }
        }

        internal static class SubscribeWasmInterop
        {
            [DllImport("wasi:sockets/tls@0.2.0", EntryPoint = "[method]future-streams.subscribe"), WasmImportLinkage]
            internal static extern int wasmImportSubscribe(int p0);

        }

        internal   unsafe global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IPoll.Pollable Subscribe()
        {
            var handle = this.Handle;
            var result =  SubscribeWasmInterop.wasmImportSubscribe(handle);
            var resource = new global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IPoll.Pollable(new global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IPoll.Pollable.THandle(result));
            return resource;

            //TODO: free alloc handle (interopString) if exists
        }

        internal static class GetWasmInterop
        {
            [DllImport("wasi:sockets/tls@0.2.0", EntryPoint = "[method]future-streams.get"), WasmImportLinkage]
            internal static extern void wasmImportGet(int p0, nint p1);

        }

        internal   unsafe Result<Result<(global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IStreams.InputStream, global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IStreams.OutputStream), None>, None>? Get()
        {
            var handle = this.Handle;

            var retArea = new uint[5];
            fixed (uint* retAreaByte0 = &retArea[0])
            {
                var ptr = (nint)retAreaByte0;
                GetWasmInterop.wasmImportGet(handle, ptr);

                Result<Result<(global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IStreams.InputStream, global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IStreams.OutputStream), None>, None>? lifted12;

                switch (new Span<byte>((void*)(ptr + 0), 1)[0]) {
                    case 0: {
                        lifted12 = null;
                        break;
                    }

                    case 1: {

                        Result<Result<(global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IStreams.InputStream, global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IStreams.OutputStream), None>, None> lifted11;

                        switch (new Span<byte>((void*)(ptr + 4), 1)[0]) {
                            case 0: {

                                Result<(global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IStreams.InputStream, global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IStreams.OutputStream), None> lifted;

                                switch (new Span<byte>((void*)(ptr + 8), 1)[0]) {
                                    case 0: {
                                        var resource = new global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IStreams.InputStream(new global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IStreams.InputStream.THandle(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 12), 4))));
                                        var resource6 = new global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IStreams.OutputStream(new global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IStreams.OutputStream.THandle(BitConverter.ToInt32(new Span<byte>((void*)(ptr + 16), 4))));

                                        lifted = Result<(global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IStreams.InputStream, global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IStreams.OutputStream), None>.ok((resource, resource6
                                        ));
                                        break;
                                    }
                                    case 1: {

                                        lifted = Result<(global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IStreams.InputStream, global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IStreams.OutputStream), None>.err(new global::WasiTlsWorld.None());
                                        break;
                                    }

                                    default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 8), 1)[0]}");
                                }

                                lifted11 = Result<Result<(global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IStreams.InputStream, global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IStreams.OutputStream), None>, None>.ok(lifted);
                                break;
                            }
                            case 1: {

                                lifted11 = Result<Result<(global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IStreams.InputStream, global::WasiTlsWorld.wit.imports.wasi.io.v0_2_0.IStreams.OutputStream), None>, None>.err(new global::WasiTlsWorld.None());
                                break;
                            }

                            default: throw new ArgumentException($"invalid discriminant: {new Span<byte>((void*)(ptr + 4), 1)[0]}");
                        }

                        lifted12 = lifted11;
                        break;
                    }

                    default: throw new ArgumentException("invalid discriminant: " + (new Span<byte>((void*)(ptr + 0), 1)[0]));
                }
                return lifted12;
            }

            //TODO: free alloc handle (interopString) if exists
        }

    }

}
